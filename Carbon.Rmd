---
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##### Carbon stocks assessment with National Forest Inventories Data

**Loading the required Packages**

```{r, message=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(stringr)
library(maps)
library(mapdata)
library(maptools)
library(sp)
library(raster)
library(BIOMASS)
library(ape)
library(magrittr)
# tinytex::install_tinytex()
library(tinytex)
```
**load the dataframe**

```{r}
Trees <- read.csv("Data_Output/MainFrame.csv")
Trees$District <- str_replace(Trees$District,"PYAY","Pyay")
str(Trees)
unique(Trees$District)
unique(Trees$Township)
table(Trees$Year)

```

Omitting the EAST and NORT with NA values and taxonomy of trees are corrected by using the to correct typos in scientific names using the Taxonomic Name Resolution Service 

```{r, message=FALSE}
Trees <- Trees[!is.na(Trees$NORTH),]
sum(is.na(Trees$EAST))
dim(Trees)
TreesNA <- Trees[Trees$Species=="NA",]
Trees <- Trees[!is.na(Trees$Species),]
str(Trees)
summary(Trees)
unique(Trees$District)
```

**Obtaining wood density**

Obtaining Wood density - getWoodDensity assigns to each taxon a species- or genus-level average if at least one wood density value in the same genus as the focal taxon is available in the reference database. For unidentified trees or if the genus is missing in the reference database, the stand-level mean wood density is assigned to the tree (based on trees for which a value was attributed).

```{r, message=FALSE}
Taxo <- correctTaxo(genus= Trees$Genus, species = Trees$Species)
Trees$genusCorr <- Taxo$genusCorrected
Trees$speciesCorr <- Taxo$speciesCorrected

APG <- getTaxonomy(Trees$genusCorr, findOrder =T)

Trees$familyAPG <- APG$family

Trees$orderAPG <- APG$order
dataWD <- getWoodDensity(genus=Trees$genusCorr,
                         species=Trees$speciesCorr,
                         stand=NULL, family = Trees$familyAPG, region = "World")

Trees <- Trees %>% mutate(DBH_cm=DBH_mm/10) %>% mutate(WD=dataWD$meanWD)

```

**Building a Diameter Height Model based on the first year data**

```{r, message=FALSE}
library(lme4)
Forests <- read.csv("Data/All_data_Final.csv")
names(Forests)
Forests <- filter(Forests,!is.na(Species_names) & !is.na(Dbh_cm))
summary(Forests)
unique(Forests$Forest_type)
Selected_Forests <- Forests %>% filter(Forest_type=="Moist_Mixed_Deciduous_Forest"| Forest_type=="Dry_Mixed_Deciduous_Forest")
LogDH_Selected_Forests <- Selected_Forests %>% mutate(LogDbh_cm=log(Dbh_cm)) %>% mutate(LogH_m=log(H_m))
ggplot(data = Selected_Forests, aes(Dbh_cm, H_m, color=Forest_type) )+ geom_point()
ModelForHeight <- lmer(log(H_m)~log(Dbh_cm)+(1|Plot_id), REML = FALSE, data = Selected_Forests)
ModelForHeight
ranef(ModelForHeight)$Plot_id[,1] %>% hist()

ModelForHeight_Log <- lmer(LogH_m~LogDbh_cm +(1|Plot_id), REML = FALSE, data = LogDH_Selected_Forests)
ModelForHeight_Log
```
__**The best possible random effect model**__

```{r}
summary(ModelForHeight_Log)
ranef(ModelForHeight_Log)$Plot_id[,1] %>% hist()
```
Getting tree Height based on the best model and substracted the lowest random effect of the plot no. 115 from every plots of the dataframe that I need to predict Height. Plot no. 115 had the lowest random effect number.

```{r}
Trees$H_pred <- predict(ModelForHeight_Log, data.frame(LogDbh_cm= log(Trees$DBH_cm), Plot_id=115))
Trees <- Trees %>%
  mutate(AdjustH_Pred=exp(H_pred-0.0007450583))
```
Testing the DBH and Height relationship for trees-----

```{r}
names(Trees)
ggplot(data = Trees, aes(DBH_cm, AdjustH_Pred, color=District) )+ geom_point()
```

**_Calculating the biomass of each tree_**

Where, D = Tree diameter (in cm), either a vector or a single value
Wood density (in g/cm3), either a vector or a single value.
Tree height (H in m), either a vector or a single value.

```{r, message=FALSE}
CoordsH <- cbind(Trees$EAST, Trees$NORTH)
Trees <- Trees %>% mutate(AGB=computeAGB(D = DBH_cm, WD = WD, H = AdjustH_Pred, coord = CoordsH, Dlim = NULL))
Trees <- Trees %>% mutate(Carbon_Mg= AGB*0.471)
write.csv(Trees, file = "Data_Output/Trees.csv", row.names = F)
```

**Sampling Method**

image: ![](Figures/Sampling Design.PNG)

1 ha sample plot with a 50m * 50 m nested plot. Therefore, the big dataframe was splitted into two. *(100m x 100m and 50m x 50m)*  

```{r}
Trees <- read.csv("Data_Output/Trees.csv")
Trees_1ha <- Trees %>% filter(DBH_mm >= 200)
Trees_50m <- Trees %>% filter(DBH_mm < 200)
nlevels(Trees$Plot_names)
```

** Calculating the carbon per ha for two different size plots**  

```{r}
Plot_1ha <- Trees_1ha %>%
  group_by(Plot_names,District,Year) %>%
  dplyr::summarise(C_ha = sum(Carbon_Mg))

Plot_50M <- Trees_50m %>%
  group_by(Plot_names,District,Year) %>%
  dplyr::summarise(C_Tree_total = sum(Carbon_Mg)) %>%
  mutate(C_ha=C_Tree_total/0.25) %>% dplyr::select(-C_Tree_total)

```
Combining two dataframes of different plot size according to Plot names.In this process, *NA* values- generated were replaced with zero in order to add carbon per ha of different plot size together. 

```{r}
All_Plots <- bind_rows(Plot_1ha,Plot_50M) %>% group_by(Plot_names) %>% summarise(CAR=sum(C_ha))


# 
# Missing_DistrictX <- is.na(All_Plots$District.x)
# All_Plots$District.x[Missing_DistrictX] <- All_Plots$District.y[Missing_DistrictX]
# 
# 
# Missing_DistrictY <- is.na(All_Plots$District.y)
# All_Plots$District.y[Missing_DistrictY]<- All_Plots$District.x[Missing_DistrictY]
# 
# 
# 
# Missing_YearX <- is.na(All_Plots$Year.x)
# All_Plots$Year.x[Missing_YearX] <- All_Plots$Year.y[Missing_DistrictX]
# 
# 
# Missing_YearY <- is.na(All_Plots$Year.y)
# All_Plots$Year.y[Missing_YearY]<- All_Plots$Year.x[Missing_YearY]
# 
# 
# Missing_50 <- is.na(All_Plots$C_ha.y)
# All_Plots$C_ha.y[Missing_50] <- 0
# 
# Missing_100 <- is.na(All_Plots$C_ha.x)
# All_Plots$C_ha.x[Missing_100] <- 0
# 
# Missing_CT_total <- is.na(All_Plots$C_Tree_total)
# All_Plots$C_Tree_total[Missing_CT_total] <- 0
# 
# sum(!duplicated(All_Plots))
# 


```

Carbon per hectare columns of the two dataframes were added together to obtain total carbon of each plot in hectare scale. 

```{r}
All_Plots_Carbon <- All_Plots %>% mutate(Carbon_THa = C_ha.x+ C_ha.y) %>% dplyr::select(-C_Tree_total,-District.y,-Year.y)
hist(All_Plots_Carbon$Carbon_THa, breaks=100)

```

**Producing a clean dataframe**

```{r}
All_Plots_Carbon <- All_Plots_Carbon %>% rename(District =District.x, Year=Year.x,Carbon_100m = C_ha.x, Carbon_50m = C_ha.y)


All_Plots_Carbon <- All_Plots_Carbon %>% drop_na()
sum(is.na(All_Plots_Carbon))
Duplinames <- All_Plots_Carbon[duplicated(All_Plots_Carbon$Plot_names),]



All_Plots_Carbon$Year <- as.factor(All_Plots_Carbon$Year)
summary(All_Plots_Carbon)
```
```{r}
ggplot(data = All_Plots_Carbon, aes(x = District, y= Carbon_THa, color= Year))+ 
  geom_boxplot()+
  labs(title = "Carbon storage per ha in 21 disctricts from 2010 to 2017", 
       x= "District name",
       y= "Carbon(t/ha)")+
  theme(axis.text.x = element_text(size=7, angle = 90, vjust = 0.5),
        axis.text.y = element_text(size = 7))
```

**Produce a cleaned data frame for per ha carbon for each plot**

```{r}
write.csv(All_Plots_Carbon,file = "Data_Output/Carbon_Per_Plots.csv",row.names = FALSE)
```
** comparing Carbon with new model and old model for height prediction**
```{r}
Comparison <- read.csv("Data_Output/Plots_Carbon.csv")
attach(Comparison)
ggplot(data=Comparison, aes(x=New_Carbon, y = Old_Carbon, color=District))+ geom_point()
detach(Comparison)
```

**Carbon according to WWF's ecoregions** 

```{r}
Ecoregions <- read.csv("Data_Output/Plots_WWFecoregions.csv")
Eco_Carbon <- Ecoregions %>% group_by(ECO_NAME) %>% summarise(MaxCarbon=max(New_Carbon), Count=n())
attach(Eco_Carbon)

lm.CarbonEcoregions <- lm(New_Carbon~ECO_NAME, data = Ecoregions)
anova(lm.CarbonEcoregions)
plot(lm.CarbonEcoregions)

boxplot(New_Carbon~ECO_NAME, data=Ecoregions)
aov.CarbonEcoregions <- aov(New_Carbon~ECO_NAME,data=Ecoregions)
TukeyHSD(aov.CarbonEcoregions)

ggplot(data=Eco_Carbon, aes(x=ECO_NAME, y = MaxCarbon, color=ECO_NAME))+ geom_point()+
  labs(title = "Carbon storage according to ecoregions", 
       x= "Ecoregion",
       y= "MaxCarbon(t/ha)")+
  theme(axis.text.x = element_text(size=7, angle = 45, vjust = 0.5),
        axis.text.y = element_text(size = 7))
detach(Eco_Carbon)

```
**Carbon and environmental conditions relationship** 

BIO1 = Annual Mean Temperature  
BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))  
BIO3 = Isothermality (BIO2/BIO7) (* 100)  
BIO4 = Temperature Seasonality (standard deviation *100)  
BIO5 = Max Temperature of Warmest Month  
BIO6 = Min Temperature of Coldest Month  
BIO7 = Temperature Annual Range (BIO5-BIO6)  
BIO8 = Mean Temperature of Wettest Quarter  
BIO9 = Mean Temperature of Driest Quarter  
BIO10 = Mean Temperature of Warmest Quarter  
BIO11 = Mean Temperature of Coldest Quarter  
BIO12 = Annual Precipitation  
BIO13 = Precipitation of Wettest Month  
BIO14 = Precipitation of Driest Month  
BIO15 = Precipitation Seasonality (Coefficient of Variation)  
BIO16 = Precipitation of Wettest Quarter  
BIO17 = Precipitation of Driest Quarter  
BIO18 = Precipitation of Warmest Quarter  
BIO19 = Precipitation of Coldest Quarter  

**Modelling carbon storage differences among districts and environmental impact on it**

A one-way ANOVA showed that carbon storage differed significantly between districts (F=55.27, df=20,7860, p < 0.001)  

```{r}
C_Env <- read.csv("Data/WCL_plots.csv")
lm.CarbonDistrict <- lm(New_Carbon~District, data = C_Env)
anova(lm.CarbonDistrict)
plot(lm.CarbonDistrict)
```
the test has very conclusively rejected the hypothesis that all means are equal. However, this was not due to all of the sample means being different, but rather just because one of the groups is very different from the others. In order to drill down and investigate this further we use a new test called Tukeyâ€™s range test.This will compare all of the groups in a pairwise fashion and reports on whether a significant difference exists.

```{r}
boxplot(New_Carbon~District, data=C_Env)
aov.Carbon <- aov(New_Carbon~District,data= C_Env)
TukeyHSD(aov.Carbon)
```

I performed a simple liner regression analysis on the two variables Carbon and Annual precipitaion(AP)/Annual Mean Temperature(AMT). I wish to determine wheter the AP/AMT varible is a significant predictor of the Carbon Variable. 

```{r}
plot(New_Carbon~bio12, data = C_Env)
lm.AMP <- lm(New_Carbon~bio12, data=C_Env)
anova(lm.AMP)

plot(New_Carbon~bio01, data = C_Env)
lm.AMT <- lm(New_Carbon~bio01, data=C_Env)
anova(lm.AMT)

ggplot(data=C_Env, aes(x=bio12, y = New_Carbon, color=District))+ geom_point()+
  labs(title = "Carbon storage and Annual Precipitation Relationship", 
       x= "Annual Annual Precipitation (mm)",
       y= "MaxCarbon(t/ha)")+
  theme(axis.text.x = element_text(size=7, angle = 45, vjust = 0.5),
        axis.text.y = element_text(size = 7))

# According to Year 
ggplot(data=C_Env, aes(x=bio01, y = New_Carbon, color=District))+ geom_line()+
  facet_wrap(facets = vars(Year))+
  labs(title = "Carbon storage and Annual Mean Temperature Relationship", 
       x= "Annual Mean Temperature",
       y= "MaxCarbon(t/ha)")+
  theme(axis.text.x = element_text(size=7, angle = 45, vjust = 0.5),
        axis.text.y = element_text(size = 7))

# According to Districts

ggplot(data=C_Env, aes(x=bio01, y = New_Carbon, color=District))+ geom_line()+
  facet_wrap(facets = vars(District))+
  labs(title = "Carbon storage and Annual Mean Temperature Relationship", 
       x= "Annual Mean Temperature",
       y= "MaxCarbon(t/ha)")+
  theme(axis.text.x = element_text(size=7, angle = 45, vjust = 0.5),
        axis.text.y = element_text(size = 7))


```

###### Creating a dataframe containing all variables

```{r}

Carbon <- read.csv("Data_Output/Carbon_Per_Plots.csv")
C_Env <- read.csv("Data/WCL_plots.csv") %>% dplyr::select(Plot_names,bio01, bio12) # get bio 01 and bio12 
NDVI2010 <- read.csv("Data_Output/NDVI_2010.csv") %>% dplyr::select(Plot_names, NDVI2010)
EVI2010 <- read.csv("Data_Output/EVI_2010.csv") %>% dplyr::select(Plot_names, EVI2010)
Ecoregions <- read.csv("Data_Output/Plots_WWFecoregions.csv") %>% dplyr::select(Plot_names, ECO_NAME)
Accessiilty <- read.csv("Data/distance_to_cities.csv") %>% rename(Time_min=mean) %>% dplyr::select(Plot_names, Time_min)

Overlapp <- sum(!Carbon$Plot_names%in%C_Env$Plot_names)
sum(str_detect(C_Env$Plot_names, ""))
```



